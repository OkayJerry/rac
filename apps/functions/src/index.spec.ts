// apps/functions/src/index.spec.ts
// Use a CJS-style require for compatibility with the test SDK.
const functionsTest = require('firebase-functions-test');

// Initialize the SDK in offline mode. This handles all the complex setup for us.
const testEnv = functionsTest();

// Import the entire module containing our functions so we can spy on its exports.
import * as index from './index';
// Import the logger to spy on it and suppress output.
import { logger } from 'firebase-functions';

// Spy on the .run() method of the exported Genkit flow.
// This allows us to intercept calls to the flow, check what they were called with,
// and prevent the real (network-calling) code from executing.
const mockRun = jest
  .spyOn(index.knowledgeBaseEmbedder, 'run')
  // Use mockResolvedValue to return a promise that resolves to an empty object.
  // This satisfies the expected 'ActionResult<void>' return type without needing to know its exact structure.
  .mockResolvedValue({} as any);

// Use jest.spyOn to suppress log output during tests, keeping the console clean.
jest.spyOn(logger, 'info').mockImplementation();
jest.spyOn(logger, 'log').mockImplementation();
jest.spyOn(logger, 'warn').mockImplementation();

describe('Cloud Functions', () => {
  afterEach(() => {
    // Clear mock history after each test to ensure tests are isolated.
    mockRun.mockClear();
  });

  afterAll(() => {
    // Clean up the test environment and restore all mocks.
    testEnv.cleanup();
    jest.restoreAllMocks();
  });

  describe('onKBCreate', () => {
    it('should call the knowledgeBaseEmbedder flow with document data', async () => {
      // 1. Arrange: Use the SDK to create a realistic mock Firestore snapshot.
      const snap = testEnv.firestore.makeDocumentSnapshot(
        { content: 'This is the content to be embedded.' },
        'knowledge_bases/test-doc-123'
      );

      // 2. Act: Wrap the function from our imported module and call it.
      // The SDK automatically creates the correct 'context' object.
      const wrapped = testEnv.wrap(index.onKBCreate);
      await wrapped(snap);

      // 3. Assert: Verify the Genkit flow was called with the correct payload.
      expect(mockRun).toHaveBeenCalledTimes(1);
      expect(mockRun).toHaveBeenCalledWith({
        docId: 'test-doc-123',
        content: 'This is the content to be embedded.',
      });
    });

    it('should not call the flow if content is missing', async () => {
      // Arrange
      const snap = testEnv.firestore.makeDocumentSnapshot(
        { header: 'Another Header' },
        'knowledge_bases/test-doc-456'
      );

      // Act
      const wrapped = testEnv.wrap(index.onKBCreate);
      await wrapped(snap);

      // Assert
      expect(mockRun).not.toHaveBeenCalled();
    });

    it('should not call the flow if data is missing', async () => {
      // Arrange
      const snap = testEnv.firestore.makeDocumentSnapshot(
        {},
        'knowledge_bases/test-doc-789'
      );

      // Act
      const wrapped = testEnv.wrap(index.onKBCreate);
      await wrapped(snap);

      // Assert
      expect(mockRun).not.toHaveBeenCalled();
    });
  });

  describe('helloWorld', () => {
    it('should send a hello message', () => {
      // Arrange
      const mockReq = {} as any;
      const mockRes = { send: jest.fn() } as any;

      // Act
      index.helloWorld(mockReq, mockRes);

      // Assert
      expect(mockRes.send).toHaveBeenCalledWith(
        'Hello from Firebase - Generated by @nx-toolkits/firebase!'
      );
    });
  });
});
