// apps/functions/src/index.ts
import { initializeAdminApp } from '@rac/data-access-firebase-admin';
import { logger } from 'firebase-functions';
import { onRequest } from 'firebase-functions/v2/https';
import * as functions from 'firebase-functions/v1';

import { genkit } from 'genkit';
import { vertexAI, textEmbedding004 } from '@genkit-ai/vertexai';
import { z } from 'zod';
import { FieldValue, getFirestore } from 'firebase-admin/firestore';
import { onCallGenkit } from 'firebase-functions/v2/https';

// Initialize Firebase Admin SDK for existing functionality.
initializeAdminApp();

// Initialize Genkit with the Vertex AI plugin.
const ai = genkit({
  plugins: [vertexAI({ location: 'us-central1' })],
});

// Define the flow for generating and storing embeddings.
export const knowledgeBaseEmbedder = ai.defineFlow(
  {
    name: 'knowledgeBaseEmbedder',
    inputSchema: z.object({ docId: z.string(), content: z.string() }),
    outputSchema: z.void(),
  },
  async ({ docId, content }) => {
    logger.info(`Generating embedding for docId: ${docId}`);

    const { embedding } = (
      await ai.embed({
        embedder: textEmbedding004,
        content: content,
      })
    )[0];

    await getFirestore()
      .collection('knowledge_bases')
      .doc(docId)
      .update({ embedding: FieldValue.vector(embedding) });
  }
);

// Define the flow for searching the knowledge base.
export const searchKnowledgeBaseFlow = ai.defineFlow(
  {
    name: 'searchKnowledgeBaseFlow',
    // The input schema now accepts a 'topN' parameter instead of 'limit'.
    inputSchema: z.object({ query: z.string(), topN: z.number().optional() }),
    outputSchema: z.array(z.any()), // Allow any shape for returned docs
  },
  // The function signature is updated to use 'topN' with a default value.
  async ({ query, topN = 5 }) => {
    logger.info(`Generating embedding for search query: "${query}"`);

    // 1. Generate an embedding for the user's search query.
    const { embedding: queryEmbedding } = (
      await ai.embed({
        embedder: textEmbedding004,
        content: query,
      })
    )[0];

    const db = getFirestore();
    const collectionRef = db.collection('knowledge_bases');

    // 2. Perform a k-nearest neighbor (KNN) vector search using 'topN' as the limit.
    const vectorQuery = collectionRef.findNearest('embedding', queryEmbedding, {
      limit: topN,
      distanceMeasure: 'COSINE',
    });

    const snapshot = await vectorQuery.get();

    // 3. Format and return the results.
    return snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }));
  }
);

// The v1 Firestore trigger that invokes the embedder flow.
export const onKnowledgeBaseCreate = functions
  .region('us-central1')
  .firestore.document('knowledge_bases/{docId}')
  .onCreate(async (snap) => {
    const data = snap.data();
    if (!data || typeof data.content !== 'string') {
      logger.log('Document data or content field is missing or not a string.');
      return;
    }

    await knowledgeBaseEmbedder.run({
      docId: snap.id,
      content: data.content,
    });
  });

// A v2 callable function that exposes the search flow.
export const searchKnowledgeBase = onCallGenkit({}, searchKnowledgeBaseFlow);

// Your existing v2 HTTP function.
export const helloWorld = onRequest({}, (_request, response) => {
  logger.info('Hello logs!', { structuredData: true });
  response.send('Hello from Firebase - Generated by @nx-toolkits/firebase!');
});
